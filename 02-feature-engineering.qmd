---
format:
  html:
    number-depth: 3
    css: summary-format.css
---

# Feature Engineering

## Handeling Missing Values

### Flavors of missingness

1. **MCAR - Missing Completely at Random**: The probability of being missing is the same for all case. Strategies to handle MCAR are:

  - To delete observations if you are losing less than 5% of the data.
  - To impute the data

2. **MAR - Missing At Random**: The locations of missing values in the dataset depend on some other, observed data. Strategies to handle MAR are:

  - To impute the data
  
3. **MNAR - Missing Not At Random**: It means that the probability of being missing varies for reasons that are unknown to us. Strategies to handle MNAR are:

  - To find more data about the causes for the missingness
  - To perform what-if analyses to see how sensitive the results are under various scenarios

::: {.callout-note}
So we try to find any variable change its mean based on missing values to demostrate that they are missing at random.
:::

### Imputation Process

#### Where we have missing values?

```{r}
airquality |>
  mice::md.pattern(rotate.names = FALSE) |>
  invisible()
```

After checking the plots we know that:

- We need to impute the `Ozone` column as it has 37 missing values.
- As 5 rows are missing `Solar.R` we need to train 2 model. One trained with that variable and other trained with

#### How is the relation between variables?

```{r}
library(tidymodels)

airquality |>
  pivot_longer(cols = -Ozone) |>
  ggplot(aes(value, Ozone, color = is.na(Ozone)))+
  naniar::geom_miss_point(show.legend = FALSE)+
  facet_wrap(~name, scales = "free")+
  theme_light()

```

#### How well can be predict Ozone?

```{r}
OzoneTrainSolar <- 
  na.omit(airquality)

OzoneTrain <- airquality |>
  select(-Solar.R) |>
  na.omit()

# Define Model
lasso_model <- linear_reg(
  engine = "glmnet",
  penalty = 1,
  mixture = 1
)

# Define Recipes
step_ozone <- function(x){
  
  step_poly(x,
            all_numeric_predictors(),
            degree = 2) |>
  step_interact(terms = ~(. -Ozone)^2) |>
  step_zv(all_numeric_predictors()) |>
  step_scale(all_numeric_predictors())
  
}

OzoneRecipeSolar <- 
  recipe(Ozone ~ Wind + Temp + Solar.R,
         data = OzoneTrainSolar) |>
  step_ozone()

OzoneRecipe <- 
  recipe(Ozone ~ Wind + Temp,
         data = OzoneTrain) |>
  step_ozone()


# Defining Models
OzoneSolarLmWf <- workflow(
  OzoneRecipeSolar,
  lasso_model
)

OzoneLmWf <- workflow(
  OzoneRecipe,
  lasso_model
)

# Training Models
OzoneSolarLmFit <- fit(
  OzoneSolarLmWf,
  data = OzoneTrainSolar
)

OzoneLmFit <- fit(
  OzoneLmWf,
  data = OzoneTrain
)

# Defining re-samples
set.seed(5050)
OzoneTrainSolarRs <- mc_cv(OzoneTrainSolar, times = 30)
set.seed(4040)
OzoneTrainRs <- mc_cv(OzoneTrain, times = 30)
set.seed(NULL)


# Model evaluation
fit_resamples(OzoneSolarLmWf,
              resamples = OzoneTrainSolarRs) |>
  collect_metrics()

fit_resamples(OzoneLmWf,
              resamples = OzoneTrainRs) |>
  collect_metrics()
```

#### Imputing Ozone

```{r}
impute_ozone <- function(df,
                         model1,
                         model2){
  
  df |>
  mutate(Ozone = coalesce(
    Ozone,
    predict(model1, df)$`.pred`,
    predict(model2, df)$`.pred`
  ))
  
}


AirOzoneInput <-
  airquality |>
  mutate(Ozone_NA = if_else(is.na(Ozone),"Yes", "No")) |>
  impute_ozone(OzoneSolarLmFit,
               OzoneLmFit)

OzoneSolarLmFit |>
  augment(AirOzoneInput) |>
  mutate(Ozone = coalesce(
    Ozone,
    predict(OzoneLmFit, AirOzoneInput)$`.pred`
  )) |>
  na.omit() |>
  ggplot(aes(Ozone, .pred))+
  geom_point(alpha = .4)+
  geom_abline()+
  theme_light()

```

#### Validate how inputations fits to data

```{r}
pivot_longer(AirOzoneInput,
             cols = -c(Ozone, Ozone_NA)) |>
  na.omit() |>
  ggplot(aes(value, Ozone, color = Ozone_NA))+
  geom_point(show.legend = FALSE)+
  scale_color_manual(values = c("Yes" = "red",
                                "No" = "grey60"))+
  facet_wrap(~name, scales = "free")+
  theme_light()
```


#### How is the relation between variables?

```{r}
AirOzoneInput |>
  select(-Ozone_NA) |>
  pivot_longer(cols = -Solar.R) |>
  ggplot(aes(value, Solar.R, color = is.na(Solar.R)))+
  naniar::geom_miss_point(show.legend = FALSE)+
  facet_wrap(~name, scales = "free")+
  theme_light()

```


#### How well can be predict Solar.R?

```{r}
# Define Model
knn_model <- nearest_neighbor(
  mode = "regression",
  neighbors = tune()
)


# Defining Recipe
SolarRecipe <- 
  recipe(Solar.R ~ .,
         data = AirOzoneInput) |>
  step_rm(Ozone_NA) |>
  step_poly(all_numeric_predictors(),
            degree = 2) |>
  step_interact(terms = ~(. -Solar.R)^2) |>
  step_zv(all_numeric_predictors()) |>
  step_range()


# Defining Models
SolarKnnWf <- workflow(
  SolarRecipe,
  knn_model
)

# Defining re-samples
set.seed(5154)
SolarRs <- mc_cv(AirOzoneInput, times = 30)
set.seed(NULL)

# Model evaluation
SolarKnnTunned <-
  tune_grid(SolarKnnWf,
            resamples = SolarRs,
            grid = tibble(neighbors = 1:50),
            metrics = metric_set(rsq))

show_best(SolarKnnTunned)

# Training Models
SolarKnnFit <- 
  SolarKnnWf |>
  finalize_workflow(select_best(SolarKnnTunned)) |>
  fit(data = AirOzoneInput)
```

#### Imputing Solar.R

```{r}
AirInputed <-
  AirOzoneInput |>
  mutate(Solar.R_NA = if_else(is.na(Solar.R),"Yes", "No"),
         Solar.R = coalesce(
           Solar.R,
           predict(SolarKnnFit, AirOzoneInput)$`.pred`)
  )

AirOzoneInput |>
  bind_cols(predict(SolarKnnFit, AirOzoneInput)) |>
  rsq(truth = Solar.R,
      estimate = `.pred`)

```

#### Validate how inputations fits to data

```{r}
SolarKnnFit |>
  augment(AirOzoneInput) |>
  na.omit() |>
  ggplot(aes(Solar.R, .pred))+
  geom_point(alpha = .4)+
  geom_abline()+
  theme_light()

AirInputed |>
  select(-Ozone_NA) |>
  pivot_longer(cols = -c(Solar.R, Solar.R_NA)) |>
  ggplot(aes(value, `Solar.R`, color = Solar.R_NA))+
  geom_point(show.legend = FALSE)+
  scale_color_manual(values = c("Yes" = "red",
                                "No" = "grey60"))+
  facet_wrap(~name, scales = "free")+
  theme_light()
```
